#include "std_types.h"
#include "AES_priv.h"
#include "AES_int.h"
#define KEY_SIZE 16
#define EXPANDED_KEY_SIZE 176
#define NUMBER_OF_ROUNDS 9
#define SBOX_SIZE 256
#define RCON 256
#define MULTIPLICATION 257
#define MAX_SIZE_OF_A_MESSAGE 24
#define MAX_SIZE_OF_A_CIPHEREDDATA 32
void AES_Dec_done(void)
{
    Dec_done_flag=1;
}
void(*ptr_Dec_Done)(void)=AES_Dec_done;
u8 Dec_done_flag=0;
void AES_Dec_Done(void)
{
 ptr_Dec_Done();
}
static u32 index1=0;
static u32 Message_Size ;
extern u8 Key[KEY_SIZE];
u8* CipheredData[MAX_SIZE_OF_A_CIPHEREDDATA];
static u8 Decrypted_Message[MAX_SIZE_OF_A_MESSAGE];
static u8 Dec_Request_Flag=0;
typedef enum {
    FirstDeRound =0,
NineDeRounds,
FinalDeRound
}enumAES_status;
enumAES_status AESDe_status= FirstDeRound ;
enumModuleStatus Dec_Module_status=idle;
void AES_vidDecInit(void)
{
  AESDe_status= FirstDeRound ;
  Dec_Module_status=idle;
}
static const u8 SboxInverse[SBOX_SIZE] = /*for decryption*/
{ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb
, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb
, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e
, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25
, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92
, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84
, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06
, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b
, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73
, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e
, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b
, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4
, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f
, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef
, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61
, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };
static const u8 mul9[MULTIPLICATION]={

0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,
0x6c,0x65,0x7e,0x77, 0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,
0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7, 0x3b,0x32,0x29,0x20,
0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,
0xc7,0xce,0xd5,0xdc, 0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,
0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01, 0xe6,0xef,0xf4,0xfd,
0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,
0x21,0x28,0x33,0x3a, 0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,
0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa, 0xec,0xe5,0xfe,0xf7,
0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,
0x10,0x19,0x02,0x0b, 0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,
0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0, 0x47,0x4e,0x55,0x5c,
0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,
0xf6,0xff,0xe4,0xed, 0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,
0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d, 0xa1,0xa8,0xb3,0xba,
0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,
0x5d,0x54,0x4f,0x46,};
static const u8 mul11[MULTIPLICATION]=
{
0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,
0x74,0x7f,0x62,0x69, 0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,
0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9, 0x7b,0x70,0x6d,0x66,
0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,
0xbf,0xb4,0xa9,0xa2, 0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,
0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f, 0x46,0x4d,0x50,0x5b,
0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
 0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,
 0xf9,0xf2,0xef,0xe4, 0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,
 0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54, 0xf7,0xfc,0xe1,0xea,
 0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
 0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,
 0x33,0x38,0x25,0x2e, 0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,
 0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5, 0x3c,0x37,0x2a,0x21,
 0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
 0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,
 0x75,0x7e,0x63,0x68, 0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,
 0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8, 0x7a,0x71,0x6c,0x67,
 0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
 0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,
 0xbe,0xb5,0xa8,0xa3,};
static const u8 mul13[MULTIPLICATION]=
{
0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,
0x5c,0x51,0x46,0x4b, 0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,
0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b, 0xbb,0xb6,0xa1,0xac,
0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
 0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,
 0x37,0x3a,0x2d,0x20, 0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,
 0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26, 0xbd,0xb0,0xa7,0xaa,
 0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
 0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,
 0x8a,0x87,0x90,0x9d, 0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,
 0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d, 0xda,0xd7,0xc0,0xcd,
 0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
 0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,
 0x56,0x5b,0x4c,0x41, 0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,
 0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a, 0xb1,0xbc,0xab,0xa6,
 0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
 0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,
 0xeb,0xe6,0xf1,0xfc, 0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,
 0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c, 0x0c,0x01,0x16,0x1b,
 0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
 0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,
 0x80,0x8d,0x9a,0x97};
static const u8 mul14[MULTIPLICATION]=
{
0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,
0x48,0x46,0x54,0x5a, 0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,
0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba, 0xdb,0xd5,0xc7,0xc9,
0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,
0x73,0x7d,0x6f,0x61, 0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,
0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7, 0x4d,0x43,0x51,0x5f,
0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
 0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,
 0x3e,0x30,0x22,0x2c, 0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,
 0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc, 0x41,0x4f,0x5d,0x53,
 0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
  0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,
  0xe9,0xe7,0xf5,0xfb, 0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,
  0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0, 0x7a,0x74,0x66,0x68,
  0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
  0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,
  0xa4,0xaa,0xb8,0xb6, 0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,
  0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56, 0x37,0x39,0x2b,0x25,
  0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
  0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,
  0x9f,0x91,0x83,0x8d};
void Inverse_Subbyte(u8*STATE){
       u32 i;
 /* it is substitute  from STATE to table of inverse s-box */
for( i=0;i<KEY_SIZE;i++)
{
    STATE[i]= SboxInverse[STATE[i]];
}
   }
void Inverse_Mixcolumns( u8*STATE)
{

    /* the function for doing inverse mix columns by xor the substitution of elements in STATE with standered tables mul14,mu11,mu13,mu19
    for fist element then shift right muls by one for the second element in STATE_After_Inverse_Mixcolumns  */

u8  STATE_After_Inverse_Mixcolumns[KEY_SIZE];
 STATE_After_Inverse_Mixcolumns[0] = (mul14[STATE[0]] ^ mul11[STATE[1]]  ^ mul13[STATE[2]]    ^ mul9[STATE[3]]);
 STATE_After_Inverse_Mixcolumns[1] = (mul9[STATE[0]]  ^ mul14[STATE[1]]    ^ mul11[STATE[2]]   ^ mul13[STATE[3]]);
 STATE_After_Inverse_Mixcolumns[2] =(mul13[STATE[0]] ^ mul9[STATE[1]]   ^ mul14[STATE[2]]    ^ mul11[STATE[3]]);
 STATE_After_Inverse_Mixcolumns[3] =(mul11[STATE[0]] ^ mul13[STATE[1]]  ^ mul9[STATE[2]]      ^ mul14[STATE[3]]);

 STATE_After_Inverse_Mixcolumns[4] = (mul14[STATE[4]] ^ mul11[STATE[5]]  ^ mul13[STATE[6]]    ^ mul9[STATE[7]]);
  STATE_After_Inverse_Mixcolumns[5] = (mul9[STATE[4]]  ^ mul14[STATE[5]]    ^ mul11[STATE[6]]   ^ mul13[STATE[7]]);
 STATE_After_Inverse_Mixcolumns[6] = (mul13[STATE[4]] ^ mul9[STATE[5]]   ^ mul14[STATE[6]]   ^ mul11[STATE[7]]);
 STATE_After_Inverse_Mixcolumns[7] = (mul11[STATE[4]] ^ mul13[STATE[5]]  ^ mul9[STATE[6]]      ^ mul14[STATE[7]]);

 STATE_After_Inverse_Mixcolumns[8] = (mul14[STATE[8]] ^ mul11[STATE[9]]  ^ mul13[STATE[10]]    ^ mul9[STATE[11]]);
 STATE_After_Inverse_Mixcolumns[9] = (mul9[STATE[8]]  ^ mul14[STATE[9]]    ^ mul11[STATE[10]]   ^ mul13[STATE[11]]);
 STATE_After_Inverse_Mixcolumns[10] = (mul13[STATE[8]] ^ mul9[STATE[9]]   ^ mul14[STATE[10]]    ^ mul11[STATE[11]]);
 STATE_After_Inverse_Mixcolumns[11] =(mul11[STATE[8]] ^ mul13[STATE[9]]  ^ mul9[STATE[10]]      ^ mul14[STATE[11]]);

 STATE_After_Inverse_Mixcolumns[12] = (mul14[STATE[12]] ^ mul11[STATE[13]]  ^ mul13[STATE[14]]    ^ mul9[STATE[15]]);
 STATE_After_Inverse_Mixcolumns[13] = (mul9[STATE[12]]  ^ mul14[STATE[13]]    ^ mul11[STATE[14]]   ^ mul13[STATE[15]]);
 STATE_After_Inverse_Mixcolumns[14] = (mul13[STATE[12]] ^ mul9[STATE[13]]   ^ mul14[STATE[14]]    ^ mul11[STATE[15]]);
 STATE_After_Inverse_Mixcolumns[15] = (mul11[STATE[12]] ^ mul13[STATE[13]]  ^ mul9[STATE[14]]      ^ mul14[STATE[15]]);
 u32 counter;
 for(counter=0;counter<KEY_SIZE;counter++)
 {
    STATE[counter]=STATE_After_Inverse_Mixcolumns[counter];
}
}
void Inverse_ShiftRows( u8*STATE)
{
/* function of inverse shift rows  it shifts second row in STATE to right by one
    and third row to right by 2
    and fourth by 3 to right
    the fist row is still the same */

/*shift rows*/
    u32 i,counter;
   u8 STATE_After_Inverse_ShiftRows[KEY_SIZE];
   u8 Inverse_ShiftRows_Table[KEY_SIZE]={0,13,10,7,4,1,14,11,8,5,2,15,12,9,6,3};
   for(i=0;i<16;i++)
   {
   STATE_After_Inverse_ShiftRows[i] = STATE[ Inverse_ShiftRows_Table[i]];
   }
   for(counter=0; counter<KEY_SIZE ; counter++){
    STATE[counter]=STATE_After_Inverse_ShiftRows[counter];
}
}
void AES_Decryption(void)
{
/*this is the function for decrypt massages in AES algorithm
 CipheredData :this is the encrypted massage
 CipheredData_Lenght: the size of encrypted massage
 Decrypted_Message :this is the output after decryption
 Message_Size: this is the size of the original massage */
    u8 Expanded_key[EXPANDED_KEY_SIZE];
  static  u32 counter1=0;
  static u8 STATE[KEY_SIZE];
    u32 i;
    /*this for check the array of the massage and put 0 if it is not multiple of 16
and if it a multiple of 16 do not change it */
if(Dec_Request_Flag==1)
{
  Dec_Module_status=busy;
  switch (AESDe_status)
  {
        case FirstDeRound :
        AESDe_status= NineDeRounds;
        for( i=0;i<KEY_SIZE;i++){
    STATE[i]= CipheredData[i+index1];
    }
    //finalround
    keyExpansion(Key,Expanded_key);
    Addroundkey(STATE,Expanded_key+160);
    index1=index1+KEY_SIZE;
break ;

    case NineDeRounds:
        AESDe_status= FinalDeRound;
    //9round
    for(i=NUMBER_OF_ROUNDS;i>0;i--)
    {
    Inverse_ShiftRows(STATE);
    Inverse_Subbyte(STATE);
    Addroundkey(STATE,Expanded_key+KEY_SIZE*(i));
    Inverse_Mixcolumns(STATE);
    }
    break;
    case FinalDeRound:
        AESDe_status= FirstDeRound;
     /*then final round it is the last round on 16 bits it is cotains Inverse_ShiftRows Inverse_Subbyte Addroundkey */
    /*first round:*/
    Inverse_ShiftRows(STATE);
    Inverse_Subbyte(STATE);
    Addroundkey(STATE,Key);
    /*then we put the output of all this rounds in Decrypted_Message and take the second 16 bit to decrypt them */
     for( i=0;i<KEY_SIZE;i++)
        {
    Decrypted_Message[counter1]=STATE[i];
    counter1++;
        }
   if (index1>=MAX_SIZE_OF_A_CIPHEREDDATA)
    {
      Dec_Request_Flag=0;
      Dec_Module_status=idle;
      index1=0;
      AES_Dec_Done();
    }

    printf("\nThe Decrypted message is : ");
   for( i=0;i<MAX_SIZE_OF_A_MESSAGE;i++)
{
    printf("%c",Decrypted_Message[i]);
    }
}
}
}
enumAES_ReqStatus AES_RequestToDec(u8 *encr_data,u32 msgDe_Size)
{
    u32 i;
    enumAES_ReqStatus status= AES_request_denied;
     if(Dec_Request_Flag==0)
     {
         printf("%d------------%d",Message_Size,Dec_Request_Flag);
       if(Message_Size < MAX_SIZE_OF_A_MESSAGE)
       {
           for (i=0;i<MAX_SIZE_OF_A_CIPHEREDDATA;i++)
           {
                CipheredData[i]=encr_data[i];
           }
         Dec_Request_Flag=1;
          Message_Size= msgDe_Size;
         status= AES_request_accepted;
         Dec_Module_status=suspended;
     }
     printf("%d------------%d",Message_Size,Dec_Request_Flag);
   }
     return(status);
}

