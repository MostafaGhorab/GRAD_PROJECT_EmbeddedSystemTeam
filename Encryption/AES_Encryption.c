#include "std_types.h"
#include "AES_priv.h"
#include "AES_int.h"
#define KEY_SIZE 16
#define EXPANDED_KEY_SIZE 176
#define NUMBER_OF_ROUNDS 9
#define SBOX_SIZE 256
#define RCON 256
#define MULTIPLICATION 257
#define MAX_SIZE_OF_A_MESSAGE 24
#define MAX_SIZE_OF_A_CIPHEREDDATA 32
void(*ptr_Enc_Done)(void)=AES_Enc_done;
u8 enc_done_flag=0;
void AES_Enc_Done(void)
{
 ptr_Enc_Done();
}
static u32 index=0;
static u8 * message ;
static u32 Message_Size ;
extern u8 Key[KEY_SIZE];
static u8 Enc_Request_Flag=0;
u8 CipheredData[MAX_SIZE_OF_A_CIPHEREDDATA];
u8 CipherData[MAX_SIZE_OF_A_CIPHEREDDATA];
typedef enum {
    FirstDeRound =0,
NineDeRounds,
FinalDeRound
}enumAES_status;
enumAES_status AES_status= FirstDeRound ;
enumModuleStatus Enc_Module_status=idle;
void AES_vidEncInit(void)
{
   AES_status= FirstDeRound ;
    Enc_Module_status=idle;
    enc_done_flag=0;
}

static const u8 sbox[SBOX_SIZE] = /*for encryption*/
  {
//0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0
0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1
0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2
0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3
0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4
0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5
0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6
0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7
0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8
0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9
0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A
0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B
0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C
0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D
0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E
0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F
static const u8 Rcon[RCON] = {
0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d,
0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab,
0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,
0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25,
0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01,
0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,
0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa,
0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a,
0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,
0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,
0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,
0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33,
0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb};
static const u8 mul2[MULTIPLICATION]={
    0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
    0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
    0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
    0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
    0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
    0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
    0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
    0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
    0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
    0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
    0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
    0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
    0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
    0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
    0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
    0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};
static const u8 mul3[MULTIPLICATION]={
    0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,
    0x1d,0x14,0x17,0x12,0x11, 0x30,0x33,0x36,0x35,0x3c,0x3f,
    0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21, 0x60,
    0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,
    0x74,0x77,0x72,0x71, 0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,
    0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41, 0xc0,0xc3,
    0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,
    0xd7,0xd2,0xd1, 0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,
    0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1, 0xa0,0xa3,0xa6,
    0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,
    0xb2,0xb1, 0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,
    0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81, 0x9b,0x98,0x9d,0x9e,
    0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,
    0x8a, 0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,
    0xb5,0xb6,0xbf,0xbc,0xb9,0xba, 0xfb,0xf8,0xfd,0xfe,0xf7,
    0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
    0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,
    0xd6,0xdf,0xdc,0xd9,0xda, 0x5b,0x58,0x5d,0x5e,0x57,0x54,
    0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a, 0x6b,
    0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,
    0x7f,0x7c,0x79,0x7a, 0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,
    0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a, 0x0b,0x08,
    0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,
    0x1c,0x19,0x1a
};
void keyExpansioncore(u8*Input_Key , u8 counter)
{
    u32 i;
/* it is preparing the Key for key expansion by rotating lift the last column in the key  */
u32* q=( u32*)Input_Key;
*q=(*q>>8)|((*q & 0xff)<< 24);
/* then we replace any element in the last column by s-box */
//subbyte
for (i=0;i<4;i++){
 Input_Key[i]=sbox[Input_Key[i]];
}
 //Rcon
/*then we xor the last column with rcon table and put it as fist column in the new key  */
 Input_Key[0]^=Rcon[counter];
}
void keyExpansion(u8* inputkey,u8* Expanded_key)
{
    u32 i;
    u8 a;
/*this is the function for creation 16 different Key
first key is input then we take the last column and rotate it and substitutiom by s-box then substetution with rcon table
then XOR this column with the fist column and put the result as the new first column
then XOR this result with the secound column and put the new result as the second column in new key and SO ON */
//initial key
for( i=0;i<KEY_SIZE;i++)
    {
    Expanded_key[i]=inputkey[i];
}
    u32 bytegenerator=KEY_SIZE;
    u32 rconiteration=1;
    u8 Lrow[4];
while (bytegenerator<EXPANDED_KEY_SIZE){
    //read Lrow for core
    for( i=0;i<4;i++)
    Lrow[i]=Expanded_key[i+bytegenerator-4] ;
    if(bytegenerator%KEY_SIZE==0)
        {
        keyExpansioncore(Lrow,rconiteration);
        rconiteration++;
    }
    //xor
    for( a=0;a<4;a++)
        {
         Expanded_key[bytegenerator]=Expanded_key[bytegenerator-KEY_SIZE] ^ Lrow[a];
         bytegenerator++;
    }
  }
}
void Subbytes(u8*State){
    u32 i;
 /* it is substitute  from state to table of  s-box */
for( i=0;i<KEY_SIZE;i++){
    State[i]=sbox[State[i]];
}
}
void Shiftrows( u8*State)
{
    u32 i;
 /* function of  shift rows  it shift second row in state to left by one
    and third row to left by 2
    and fourth by 3 to left
    the fist row is still the same */

/*shift rows*/
   u8 ShiftRows_Table[KEY_SIZE]={0,5,10,15,4,9,14,3,8,13,2,7,12,1,6,11};
   u8 State_After_ShiftRows[KEY_SIZE];
   for(i=0;i<16;i++)
    {
   State_After_ShiftRows[i] = State[ShiftRows_Table[i]];
   }
   for(i=0; i<KEY_SIZE; i++)
    {
    State[i]=State_After_ShiftRows[i];
}
}
void Mixcolumns( u8*State)
{
/* the function for doing inverse mix columns by xor the substitution of elements in state with standard tables
     MULTIPLICATION2,mu13,1,1 for fist element then shift right MULTIPLICATIONs by one for the second element in State_After_Mixcolumns  */
u8 State_After_Mixcolumns[KEY_SIZE];
 State_After_Mixcolumns[0] = (mul2[State[0]] ^ mul3[State[1]] ^ State[2]       ^ State[3]);
 State_After_Mixcolumns[1] = (State[0]       ^ mul2[State[1]] ^ mul3[State[2]] ^ State[3]);
 State_After_Mixcolumns[2] = (State[0]       ^ State[1]       ^ mul2[State[2]] ^ mul3[State[3]]);
 State_After_Mixcolumns[3] = (mul3[State[0]] ^ State[1]       ^ State[2]       ^ mul2[State[3]]);
 State_After_Mixcolumns[4] = (mul2[State[4]] ^ mul3[State[5]] ^ State[6]       ^ State[7]);
 State_After_Mixcolumns[5] = (State[4]       ^ mul2[State[5]] ^ mul3[State[6]] ^ State[7]);
 State_After_Mixcolumns[6] = (State[4]       ^ State[5]       ^ mul2[State[6]] ^ mul3[State[7]]);
 State_After_Mixcolumns[7] = (mul3[State[4]] ^ State[5]       ^ State[6]       ^mul2[State[7]]);
 State_After_Mixcolumns[8] = (mul2[State[8]] ^ mul3[State[9]] ^ State[10]       ^ State[11]);
 State_After_Mixcolumns[9] = (State[8]       ^ mul2[State[9]] ^ mul3[State[10]] ^ State[11]);
 State_After_Mixcolumns[10] =(State[8]      ^ State[9]       ^ mul2[State[10]] ^ mul3[State[11]]);
 State_After_Mixcolumns[11] =(mul3[State[8]]^ State[9]       ^ State[10]       ^ mul2[State[11]]);

 State_After_Mixcolumns[12] =(mul2[State[12]]^ mul3[State[13]] ^ State[14]     ^ State[15]);
 State_After_Mixcolumns[13] =(State[12]      ^ mul2[State[13]] ^ mul3[State[14]] ^ State[15]);
 State_After_Mixcolumns[14] =(State[12]      ^ State[13]       ^ mul2[State[14]] ^ mul3[State[15]]);
 State_After_Mixcolumns[15] =(mul3[State[12]]^ State[13]       ^ State[14]       ^ mul2[State[15]]);
 u32 i;
 for(i=0;i<KEY_SIZE;i++){
    State[i]=State_After_Mixcolumns[i];
}
}
void Addroundkey(u8*State, u8*roundkey){
    u32 i;
/*this function xor the state with roundkey and put it in the state for 16 times for 16 key*/
 for( i=0;i<KEY_SIZE;i++)
{
    State[i]^=roundkey[i];
    }
}
void AES_Encryption(void){
    /* this function for encrypt the massage with AES algorithm
    message:is the massage to be encrypted
    Message_Size: the size of this massage
    key: the public  key for encryption and decryption
     n: the size of this key must be 16
     CipheredData: output of this function "the encrypted massage "
     CipheredData_Lenght: the length of the encrypted massage   */
static u8  Expanded_key[EXPANDED_KEY_SIZE];
/* the key that we use in encryption is used for new 16 key */
    u32 i;
    static u8 State[KEY_SIZE];
         /* array for each 16 bit of massage for doing operations on it */
  static  u32 counter=0;
    /*this for check the array of the massage and put 0 if it is not multiple of 16
and if it a multiple of 16 do not change it */

if(Enc_Request_Flag==1)
{
    enc_done_flag=0;
  Enc_Module_status=busy;
    //Can do Encryption
    /* this is for take 16 bit from massage to encrypt it and then take the another 16 and so on */
    switch(AES_status)
    {
    case FirstDeRound:
        AES_status= NineDeRounds;
          for ( i=0; i<MAX_SIZE_OF_A_CIPHEREDDATA; i++)
    {
    if(i >= Message_Size)
    {
    CipherData[i] = 0;
    }
  else
    {
      CipherData[i] = message[i];
    }
    }
     for( i=0;i<KEY_SIZE;i++)
        {
    State[i]=CipherData[i+index];
     }
     /*encryption process have initial round and 9 rounds then final round
initial round is add round key*/
keyExpansion(Key,Expanded_key);
Addroundkey(State,Key);
index=index+KEY_SIZE;
    break;
    case NineDeRounds:
        AES_status= FinalDeRound;
/*the 9 rounds repeats the operation on the same way for 9 times this operations are Subbytes shiftrows mixcolmn addroundkey   */
for( i=0;i<NUMBER_OF_ROUNDS;i++)
    {
    Subbytes(State);
    Shiftrows(State);
    Mixcolumns(State);
    Addroundkey(State,KEY_SIZE*(i+1)+Expanded_key);
}
    break;
   case FinalDeRound:
        AES_status= FirstDeRound;
/*then final round it is the last round on 16 bits it is cotains subbytes shiftrows addroundkey */
//finalround
    Subbytes(State);
    Shiftrows(State);
    Addroundkey(State,Expanded_key+160);
    /*then we put the output of all this rounds in cipheredData and take the second 16 bit to encrypt them */
   printf("\n %d",index);
    for( i=0;i<KEY_SIZE;i++)
    {
    CipheredData[counter]=State[i];
    counter++;
    }
      if (index>=MAX_SIZE_OF_A_CIPHEREDDATA )
    {
      Enc_Request_Flag=0;
      Enc_Module_status=idle;
      index=0;
      AES_Enc_Done();
    }
  printf("\nThe encrypted message is : ");
   for(i=0;i< MAX_SIZE_OF_A_CIPHEREDDATA ;i++)
{
   // printf("%x",global_encr_msg[i]);
printf("%x",CipheredData[i]);
    }
}
}
}
enumAES_ReqStatus AES_RequestToEnc(u8*msg,u32 msg_Size)
{
    enumAES_ReqStatus status= AES_request_denied;
     if(Enc_Request_Flag==0)
     {
          printf("%d------------%d",Message_Size,Enc_Request_Flag);
       if(Message_Size < MAX_SIZE_OF_A_MESSAGE)
       {
         Enc_Request_Flag=1;
         message=msg;
         Message_Size= msg_Size;
         status= AES_request_accepted;
         Enc_Module_status=suspended;
     }
     printf("%d------------%d",Message_Size,Enc_Request_Flag);
   }
     return(status);
}
void AES_Enc_done(void)
{
    enc_done_flag=1;
}
enumAES_DataStaus AES_EncDataGetter(u8 * data)
{
    enumAES_DataStaus datastatues=data_not_available;
    u32 i;
    if (enc_done_flag==1)
    {
        for(i=0; i < MAX_SIZE_OF_A_CIPHEREDDATA; i++)
        {
            data[i]=CipheredData[i];
        }
        datastatues=data_available;
        printf("\ndone");
    }

    return(datastatues);
}
